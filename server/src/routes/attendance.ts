import { Router, type Response } from "express"
import { z } from "zod"
import { prisma } from "../db"
import { requireAuth } from "../middleware/auth"
import type { AuthenticatedRequest } from "../types"

export const router = Router()
const db = prisma as any

// Require authentication for all routes
router.use(requireAuth)

const markAttendanceSchema = z.object({
    mentorId: z.string().min(1),
    groupId: z.string().min(1), // this is classId
    timestamp: z.number().int().positive()
})

// POST /api/attendance/mark
router.post("/mark", async (req: AuthenticatedRequest, res: Response) => {
    try {
        const userId = req.user!.id
        const parsed = markAttendanceSchema.safeParse(req.body)

        if (!parsed.success) {
            return res.status(400).json({ error: parsed.error.flatten() })
        }

        const { mentorId, groupId, timestamp } = parsed.data

        // 1. Verify timestamp freshness (e.g. 2 hours max age to prevent replay of old codes)
        const now = Date.now()
        const age = now - timestamp
        // 2 hours = 2 * 60 * 60 * 1000 = 7200000 ms
        if (age > 7200000) {
            return res.status(400).json({ error: "QR code expired" })
        }
        if (age < -60000) {
            return res.status(400).json({ error: "Invalid timestamp (future)" })
        }

        // 2. Find Active Schedule for this Group and Mentor for Today
        // We look for a schedule for this `groupId` (classId) on the current date
        const today = new Date()
        today.setHours(0, 0, 0, 0)
        const tomorrow = new Date(today)
        tomorrow.setDate(tomorrow.getDate() + 1)

        let schedule = await db.schedule.findFirst({
            where: {
                classId: groupId,
                scheduledDate: { gte: today, lt: tomorrow },
                status: { not: "CANCELLED" }
                // createdById: mentorId // Optional: restrict to specific mentor's schedule?
                // But if the Mentor substitutes, they might scan. 
                // However, the QR contains `mentorId`, so we trust the QR was generated by `mentorId`.
            }
        })

        if (!schedule) {
            // Fallback: Check if there is a schedule without classId but with kruzhokId?
            // Or maybe the frontend passes a bad groupId?
            // For now, if no schedule exists, we can't mark attendance in strict schema.
            // Option: Create an ad-hoc schedule?
            // "Auto-create schedule" if missing?
            // Let's create one for "Ad-hoc Lesson" if missing.

            // Get class info to link Kruzhok
            const cls = await db.clubClass.findUnique({ where: { id: groupId } })
            if (!cls) return res.status(404).json({ error: "Group not found" })

            schedule = await db.schedule.create({
                data: {
                    kruzhokId: cls.kruzhokId,
                    classId: groupId,
                    title: "Занятие (QR)",
                    scheduledDate: new Date(),
                    scheduledTime: new Date().toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' }),
                    durationMinutes: 60,
                    createdById: mentorId, // The mentor in the QR started it
                    status: "IN_PROGRESS"
                }
            })
        }

        // 3. Check if student is already marked
        const existing = await db.attendance.findUnique({
            where: {
                scheduleId_studentId: {
                    scheduleId: schedule.id,
                    studentId: userId
                }
            }
        })

        if (existing) {
            return res.json({ success: true, message: "Already marked" })
        }

        // 4. Mark Attendance
        await db.attendance.create({
            data: {
                scheduleId: schedule.id,
                studentId: userId,
                status: "PRESENT",
                markedById: mentorId, // Marked essentially by the mentor providing the QR
                markedAt: new Date()
            }
        })

        // 5. Notify Parent
        const student = await db.user.findUnique({
            where: { id: userId },
            select: { fullName: true, parentId: true }
        })

        if (student?.parentId) {
            await db.notification.create({
                data: {
                    userId: student.parentId,
                    title: "Посещаемость",
                    message: `${student.fullName} прибыл(а) на занятие.`,
                    type: "ATTENDANCE"
                }
            })
        }

        res.json({ success: true, date: schedule.scheduledDate })
    } catch (error) {
        console.error("[attendance/mark] Error:", error)
        res.status(500).json({ error: "Internal server error" })
    }
})
